import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:http/http.dart' as http;
import 'package:quickalert/quickalert.dart';
import 'dart:convert';

import 'package:restaurapp/common/constants/constants.dart';
import 'package:restaurapp/page/orders/orders_controller.dart';

// Modelos para las entidades
class Category {
  final int id;
  final String nombreCategoria;
  final String descripcion;
  final bool status;

  Category({
    required this.id,
    required this.nombreCategoria,
    required this.descripcion,
    required this.status,
  });

  factory Category.fromJson(Map<String, dynamic> json) {
    return Category(
      id: json['id'] ?? 0,
      nombreCategoria: json['nombreCategoria'] ?? '',
      descripcion: json['descripcion'] ?? '',
      status: json['status'] ?? false,
    );
  }
}

class Mesa {
  final int id;
  final int numeroMesa;
  final bool status;

  Mesa({
    required this.id,
    required this.numeroMesa,
    required this.status,
  });

  factory Mesa.fromJson(Map<String, dynamic> json) {
    return Mesa(
      id: json['id'] ?? 0,
      numeroMesa: json['numeroMesa'] ?? 0,
      status: json['status'] ?? false,
    );
  }
}

class Producto {
  final int id;
  final String nombre;
  final String descripcion;
  final String precio;
  final int tiempoPreparacion;
  final String imagen;
  final String categoria;

  Producto({
    required this.id,
    required this.nombre,
    required this.descripcion,
    required this.precio,
    required this.tiempoPreparacion,
    required this.imagen,
    required this.categoria,
  });

  factory Producto.fromJson(Map<String, dynamic> json) {
    return Producto(
      id: json['id'] ?? 0,
      nombre: json['nombre'] ?? '',
      descripcion: json['descripcion'] ?? '',
      precio: json['precio']?.toString() ?? '0', // ‚úÖ Convertir a string si no lo es
      tiempoPreparacion: json['tiempoPreparacion'] ?? 0,
      imagen: json['imagen']?.toString() ?? '', // ‚úÖ Manejar null y convertir a string
      categoria: json['categoria']?.toString() ?? '', // ‚úÖ Manejar null
    );
  }

  double get precioDouble => double.tryParse(precio) ?? 0.0;
  
  bool get tieneImagen => imagen.isNotEmpty;
  
  String get imagenSegura => imagen.isEmpty ? 'assets/images/no-image.png' : imagen;
}

class CartItem {
  final Producto producto;
  int cantidad;
  String observaciones;

  CartItem({
    required this.producto,
    required this.cantidad,
    this.observaciones = '',
  });

  double get subtotal => producto.precioDouble * cantidad;

  Map<String, dynamic> toJson() {
    return {
      'productoId': producto.id,
      'cantidad': cantidad,
      'observaciones': observaciones.isEmpty ? '' : observaciones, // ‚úÖ Asegurar que no sea null
    };
  }
}

// Controller GetX para crear √≥rdenes
class CreateOrderController extends GetxController {
  var isLoading = false.obs;
  var isLoadingCategories = false.obs;
  var isLoadingProducts = false.obs;
  var isLoadingMesas = false.obs;
  var isCreatingOrder = false.obs;
  var searchText = ''.obs;

  var categorias = <Category>[].obs;
  var mesas = <Mesa>[].obs;
  var todosLosProductos = <Producto>[].obs;
  var productosPorCategoria = <Producto>[].obs;
  var cartItems = <CartItem>[].obs;

  var selectedCategoryIndex = 0.obs;
  var selectedMesa = Rx<Mesa?>(null);
  var nombreOrden = ''.obs;

  String defaultApiServer = AppConstants.serverBase;
 var isSearching = false.obs;
  var searchQuery = ''.obs;
  var searchResults = <Producto>[].obs;
  var showSearchResults = false.obs;
  var isLoadingSearch = false.obs;
  @override
  void onInit() {
    super.onInit();
    cargarDatosIniciales();
  }/// ‚úÖ CORREGIDO: Buscar productos por nombre usando POST con body
Future<void> buscarProductos(String query) async {
  try {
    searchQuery.value = query.trim();
    
    // Si la b√∫squeda est√° vac√≠a, ocultar resultados
    if (searchQuery.value.isEmpty) {
      showSearchResults.value = false;
      searchResults.clear();
      return;
    }

    // Mostrar que estamos buscando
    isLoadingSearch.value = true;
    showSearchResults.value = true;

    // Preparar datos para enviar en el body
    final searchData = {
      'nombre': searchQuery.value
    };

    Uri uri = Uri.parse('$defaultApiServer/menu/buscarProductoMenu/');
    
    print('üîç Buscando productos: ${searchQuery.value}');
    print('üì° URL de b√∫squeda: $uri');
    print('üì§ Datos de b√∫squeda en body: $searchData');

    // ‚úÖ OPCI√ìN 1: GET con body (no est√°ndar pero funcional)
    final request = http.Request('GET', uri);
    request.headers.addAll({
      'Content-Type': 'application/json',
      'Accept': 'application/json',
    });
    request.body = jsonEncode(searchData);
    
    final streamedResponse = await request.send().timeout(Duration(seconds: 15));
    final response = await http.Response.fromStream(streamedResponse);

    print('üì° B√∫squeda - C√≥digo: ${response.statusCode}');
    print('üìÑ Respuesta: ${response.body}');

    if (response.statusCode == 200) {
      if (response.body.isEmpty) {
        searchResults.clear();
        return;
      }
      
      final dynamic decodedData = jsonDecode(response.body);
      
      if (decodedData is! List) {
        throw Exception('Formato de respuesta inv√°lido - esperaba una lista');
      }
      
      final List<dynamic> data = decodedData;
      
      // Parsear productos encontrados
      searchResults.value = data
          .map((json) {
            try {
              return Producto.fromJson(json);
            } catch (e) {
              print('‚ö†Ô∏è Error al parsear producto de b√∫squeda: $json - Error: $e');
              return null;
            }
          })
          .where((producto) => producto != null)
          .cast<Producto>()
          .toList();
          
      print('‚úÖ Productos encontrados: ${searchResults.length}');
      
    } else {
      throw Exception('Error del servidor: ${response.statusCode}');
    }
  } catch (e) {
    print('‚ùå Error en b√∫squeda: $e');
    searchResults.clear();
    
   
  } finally {
    isLoadingSearch.value = false;
  }
}
  void limpiarBusqueda() {
    searchQuery.value = '';
    searchResults.clear();
    showSearchResults.value = false;
    isLoadingSearch.value = false;
  }

  /// ‚úÖ NUEVO: Cerrar b√∫squeda y volver a categor√≠as
  void cerrarBusqueda() {
    limpiarBusqueda();
    // Recargar productos de la categor√≠a actual
    if (categorias.isNotEmpty && selectedCategoryIndex.value < categorias.length) {
      final categoria = categorias[selectedCategoryIndex.value];
      obtenerProductosPorCategoria(categoria.id);
    }
  }

  /// Cargar todos los datos necesarios al inicializar
  Future<void> cargarDatosIniciales() async {
    isLoading.value = true;
    try {
      await Future.wait([
        obtenerCategorias(),
        obtenerMesas(),
        obtenerTodosLosProductos(),
      ]);
      
      // Cargar productos de la primera categor√≠a por defecto
      if (categorias.isNotEmpty) {
        await obtenerProductosPorCategoria(categorias.first.id);
      }
    } catch (e) {
      print('‚ùå Error en cargarDatosIniciales: $e');
      _mostrarError('Error de Inicializaci√≥n', 'No se pudieron cargar los datos iniciales: $e');
    } finally {
      isLoading.value = false;
    }
  }

  /// Obtener todas las categor√≠as
  Future<void> obtenerCategorias() async {
    try {
      isLoadingCategories.value = true;
      
      Uri uri = Uri.parse('$defaultApiServer/menu/listarCategorias/');
      
      final response = await http.get(
        uri,
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
        },
      ).timeout(Duration(seconds: 30)); // ‚úÖ Agregar timeout

      print('üì° Categor√≠as - C√≥digo: ${response.statusCode}');
      print('üìÑ Respuesta: ${response.body}');

      if (response.statusCode == 200) {
        // ‚úÖ Verificar que la respuesta no est√© vac√≠a
        if (response.body.isEmpty) {
          throw Exception('Respuesta vac√≠a del servidor');
        }
        
        final dynamic decodedData = jsonDecode(response.body);
        
        // ‚úÖ Verificar que sea una lista
        if (decodedData is! List) {
          throw Exception('Formato de respuesta inv√°lido - esperaba una lista');
        }
        
        final List<dynamic> data = decodedData;
        categorias.value = data
            .map((json) {
              try {
                return Category.fromJson(json);
              } catch (e) {
                print('‚ö†Ô∏è Error al parsear categor√≠a: $json - Error: $e');
                return null;
              }
            })
            .where((cat) => cat != null && cat.status) // Solo categor√≠as activas y v√°lidas
            .cast<Category>()
            .toList();
      } else {
        throw Exception('Error del servidor: ${response.statusCode}');
      }
    } catch (e) {
      print('‚ùå Error al obtener categor√≠as: $e');
     // _mostrarError('Error al cargar categor√≠as', 'No se pudieron cargar las categor√≠as: $e');
    } finally {
      isLoadingCategories.value = false;
    }
  }

  /// Obtener todas las mesas
  Future<void> obtenerMesas() async {
    try {
      isLoadingMesas.value = true;
      
      Uri uri = Uri.parse('$defaultApiServer/mesas/listarMesas/');
      
      final response = await http.get(
        uri,
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
        },
      ).timeout(Duration(seconds: 30)); // ‚úÖ Agregar timeout

      print('üì° Mesas - C√≥digo: ${response.statusCode}');
      print('üìÑ Respuesta: ${response.body}');

      if (response.statusCode == 200) {
        // ‚úÖ Verificar que la respuesta no est√© vac√≠a
        if (response.body.isEmpty) {
          throw Exception('Respuesta vac√≠a del servidor');
        }
        
        final dynamic decodedData = jsonDecode(response.body);
        
        // ‚úÖ Verificar que sea una lista
        if (decodedData is! List) {
          throw Exception('Formato de respuesta inv√°lido - esperaba una lista');
        }
        
        final List<dynamic> data = decodedData;
        mesas.value = data
            .map((json) {
              try {
                return Mesa.fromJson(json);
              } catch (e) {
                print('‚ö†Ô∏è Error al parsear mesa: $json - Error: $e');
                return null;
              }
            })
            .cast<Mesa>()
            .toList();
      } else {
        throw Exception('Error del servidor: ${response.statusCode}');
      }
    } catch (e) {
      print('‚ùå Error al obtener mesas: $e');
     // _mostrarError('Error al cargar mesas', 'No se pudieron cargar las mesas: $e');
    } finally {
      isLoadingMesas.value = false;
    }
  }

  /// Obtener todo el men√∫ - üîß CORREGIDO para manejar null
  Future<void> obtenerTodosLosProductos() async {
    try {
      isLoadingProducts.value = true;
      
      Uri uri = Uri.parse('$defaultApiServer/menu/listarTodoMenu/');
      
      final response = await http.get(
        uri,
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
        },
      ).timeout(Duration(seconds: 30)); // ‚úÖ Agregar timeout

      print('üì° Todo el men√∫ - C√≥digo: ${response.statusCode}');
      print('üìÑ Respuesta: ${response.body}');

      if (response.statusCode == 200) {
        // ‚úÖ Verificar que la respuesta no est√© vac√≠a
        if (response.body.isEmpty) {
          throw Exception('Respuesta vac√≠a del servidor');
        }
        
        final dynamic decodedData = jsonDecode(response.body);
        
        // ‚úÖ Verificar que sea una lista
        if (decodedData is! List) {
          throw Exception('Formato de respuesta inv√°lido - esperaba una lista');
        }
        
        final List<dynamic> data = decodedData;
        
        // üîß SOLUCI√ìN: Filtrar y manejar productos con campos null
        todosLosProductos.value = data
            .map((json) {
              try {
                return Producto.fromJson(json);
              } catch (e) {
                print('‚ö†Ô∏è Error al parsear producto: $json - Error: $e');
                return null; // Retornar null si hay error en el parsing
              }
            })
            .where((producto) => producto != null) // Filtrar productos null
            .cast<Producto>() // Cast seguro despu√©s del filtrado
            .toList();
            
        print('‚úÖ Productos cargados correctamente: ${todosLosProductos.length}');
        
      } else {
        throw Exception('Error del servidor: ${response.statusCode}');
      }
    } catch (e) {
      print('‚ùå Error al obtener todo el men√∫: $e');
    //  _mostrarError('Error al cargar men√∫', 'No se pudo cargar el men√∫: $e');
    } finally {
      isLoadingProducts.value = false;
    }
  }

  /// Obtener productos por categor√≠a - üîß CORREGIDO para manejar null
  Future<void> obtenerProductosPorCategoria(int categoriaId) async {
    try {
      isLoadingProducts.value = true;
      
      Uri uri = Uri.parse('$defaultApiServer/menu/listarMenuPorCategoria/$categoriaId/');
      
      final response = await http.get(
        uri,
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
        },
      ).timeout(Duration(seconds: 30)); // ‚úÖ Agregar timeout

      print('üì° Productos por categor√≠a $categoriaId - C√≥digo: ${response.statusCode}');
      print('üìÑ Respuesta: ${response.body}');

      if (response.statusCode == 200) {
        // ‚úÖ Verificar que la respuesta no est√© vac√≠a
        if (response.body.isEmpty) {
          throw Exception('Respuesta vac√≠a del servidor');
        }
        
        final dynamic decodedData = jsonDecode(response.body);
        
        // ‚úÖ Verificar que sea una lista
        if (decodedData is! List) {
          throw Exception('Formato de respuesta inv√°lido - esperaba una lista');
        }
        
        final List<dynamic> data = decodedData;
        
        // üîß SOLUCI√ìN: Mismo manejo de null que en obtenerTodosLosProductos
        productosPorCategoria.value = data
            .map((json) {
              try {
                return Producto.fromJson(json);
              } catch (e) {
                print('‚ö†Ô∏è Error al parsear producto por categor√≠a: $json - Error: $e');
                return null;
              }
            })
            .where((producto) => producto != null)
            .cast<Producto>()
            .toList();
            
      } else {
        // Si falla, usar productos de esa categor√≠a del listado completo
        _filtrarProductosPorCategoria(categoriaId);
      }
    } catch (e) {
      print('‚ùå Error al obtener productos por categor√≠a: $e');
      // Si falla, usar productos de esa categor√≠a del listado completo
      _filtrarProductosPorCategoria(categoriaId);
    } finally {
      isLoadingProducts.value = false;
    }
  }

  /// Filtrar productos por categor√≠a del listado completo (fallback)
  void _filtrarProductosPorCategoria(int categoriaId) {
    try {
      final categoria = categorias.firstWhereOrNull((cat) => cat.id == categoriaId);
      if (categoria != null) {
        productosPorCategoria.value = todosLosProductos
            .where((producto) => producto.categoria == categoria.nombreCategoria)
            .toList();
      } else {
        productosPorCategoria.value = [];
      }
    } catch (e) {
      print('‚ùå Error en _filtrarProductosPorCategoria: $e');
      productosPorCategoria.value = [];
    }
  }

  /// Cambiar categor√≠a seleccionada
  void cambiarCategoria(int index) {
    try {
      if (index < categorias.length && index >= 0) {
        selectedCategoryIndex.value = index;
        final categoria = categorias[index];
        obtenerProductosPorCategoria(categoria.id);
      }
    } catch (e) {
      print('‚ùå Error en cambiarCategoria: $e');
    }
  }

  /// Seleccionar mesa
  void seleccionarMesa(Mesa? mesa) {
    try {
      selectedMesa.value = mesa;
    } catch (e) {
      print('‚ùå Error en seleccionarMesa: $e');
    }
  }

  void agregarAlCarrito(Producto producto, {String observaciones = '', bool cerrarDialog = false}) {
    try {
      final existingItemIndex = cartItems.indexWhere(
        (item) => item.producto.id == producto.id && item.observaciones == observaciones
      );

      if (existingItemIndex >= 0) {
        cartItems[existingItemIndex].cantidad++;
      } else {
        cartItems.add(CartItem(
          producto: producto,
          cantidad: 1,
          observaciones: observaciones,
        ));
      }

      // Cerrar dialog si se especifica
      if (cerrarDialog && Get.isDialogOpen == true) {
        Get.back();
      }
    } catch (e) {
      print('‚ùå Error en agregarAlCarrito: $e');
      _mostrarError('Error', 'No se pudo agregar el producto al carrito');
    }
  }

  /// Aumentar cantidad de un item en el carrito
  void aumentarCantidad(int index) {
    try {
      if (index < cartItems.length && index >= 0) {
        cartItems[index].cantidad++;
        cartItems.refresh();
      }
    } catch (e) {
      print('‚ùå Error en aumentarCantidad: $e');
    }
  }

  /// Disminuir cantidad de un item en el carrito
  void disminuirCantidad(int index) {
    try {
      if (index < cartItems.length && index >= 0) {
        if (cartItems[index].cantidad > 1) {
          cartItems[index].cantidad--;
          cartItems.refresh();
        } else {
          cartItems.removeAt(index);
        }
      }
    } catch (e) {
      print('‚ùå Error en disminuirCantidad: $e');
    }
  }

  /// Remover item del carrito
  void removerDelCarrito(int index) {
    try {
      if (index < cartItems.length && index >= 0) {
        cartItems.removeAt(index);
      }
    } catch (e) {
      print('‚ùå Error en removerDelCarrito: $e');
    }
  }

  /// Limpiar carrito
  void limpiarCarrito() {
    try {
      cartItems.clear();
      nombreOrden.value = '';
      selectedMesa.value = null;
    } catch (e) {
      print('‚ùå Error en limpiarCarrito: $e');
    }
  }

  /// Calcular total del carrito
  double get totalCarrito {
    try {
      return cartItems.fold(0.0, (sum, item) => sum + item.subtotal);
    } catch (e) {
      print('‚ùå Error en totalCarrito: $e');
      return 0.0;
    }
  }

  /// Obtener cantidad total de items en el carrito
  int get cantidadTotalItems {
    try {
      return cartItems.fold(0, (sum, item) => sum + item.cantidad);
    } catch (e) {
      print('‚ùå Error en cantidadTotalItems: $e');
      return 0;
    }
  }

  /// Generar nombre de orden por defecto
  String _generarNombreOrdenPorDefecto() {
    try {
      final now = DateTime.now();
      return 'Orden Mesa ${selectedMesa.value?.numeroMesa ?? 'Sin Mesa'}';
    } catch (e) {
      print('‚ùå Error en _generarNombreOrdenPorDefecto: $e');
      return 'Orden Sin Nombre';
    }
  }

  // ‚úÖ FUNCI√ìN PRINCIPAL CORREGIDA
  Future<bool> crearOrden({String? nombreOrdenCustom}) async {
    try {
      // ‚úÖ Validaciones mejoradas
      if (selectedMesa.value == null) {
        await _mostrarAlertaAsync(
          QuickAlertType.warning,
          'Mesa requerida',
          'Por favor selecciona una mesa antes de continuar',
          'Entendido',
          Color(0xFFFF9800),
        );
        return false;
      }

      if (cartItems.isEmpty) {
        await _mostrarAlertaAsync(
          QuickAlertType.warning,
          'Carrito vac√≠o',
          'Agrega productos al carrito antes de crear la orden',
          'Entendido',
          Color(0xFFFF9800),
        );
        return false;
      }

      isCreatingOrder.value = true;

      // ‚úÖ Manejo seguro del nombre
      String nombreFinal;
      try {
        nombreFinal = (nombreOrdenCustom?.isNotEmpty == true) 
            ? nombreOrdenCustom! 
            : _generarNombreOrdenPorDefecto();
      } catch (e) {
        print('‚ö†Ô∏è Error generando nombre, usando por defecto');
        nombreFinal = 'Orden ${DateTime.now().millisecondsSinceEpoch}';
      }

      // ‚úÖ Construcci√≥n segura del orderData
      final orderData = <String, dynamic>{
        'nombreOrden': nombreFinal,
        'mesaId': selectedMesa.value!.id,
        'productos': cartItems.map((item) {
          try {
            return item.toJson();
          } catch (e) {
            print('‚ö†Ô∏è Error serializando item: $e');
            // Versi√≥n manual como fallback
            return {
              'productoId': item.producto.id,
              'cantidad': item.cantidad,
              'observaciones': item.observaciones ?? '',
            };
          }
        }).toList(),
        'status': 'proceso',
      };

      print('üì§ Creando orden: ${jsonEncode(orderData)}');

      // ‚úÖ Validar URL del servidor
      if (defaultApiServer.isEmpty) {
        throw Exception('URL del servidor no configurada');
      }

      Uri uri = Uri.parse('$defaultApiServer/ordenes/crearOrden/');
      print('üì° URL de creaci√≥n: $uri');

      final response = await http.post(
        uri,
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json',
        },
        body: jsonEncode(orderData),
      ).timeout(Duration(seconds: 30)); // ‚úÖ Timeout

      print('üì° Crear orden - C√≥digo: ${response.statusCode}');
      print('üìÑ Respuesta: ${response.body}');

      if (response.statusCode == 200 || response.statusCode == 201) {
        // ‚úÖ Manejo seguro de la respuesta
        try {
          final responseData = response.body.isNotEmpty 
              ? jsonDecode(response.body) 
              : <String, dynamic>{};
          print('‚úÖ Orden creada exitosamente: $responseData');
        } catch (e) {
          print('‚ö†Ô∏è Error decodificando respuesta exitosa: $e');
          // Continuamos porque la orden se cre√≥ correctamente
        }
        
        // Limpiar carrito
        limpiarCarrito();
        
        // Esperar un momento antes de mostrar el alert
        await Future.delayed(Duration(milliseconds: 300));
        
          final controller2 = Get.find<OrdersController>();
          controller2.cargarDatos();
     

        return true;

      } else {
        // ‚úÖ Manejo mejorado de errores del servidor
        String errorMessage = 'Error desconocido del servidor';
        try {
          if (response.body.isNotEmpty) {
            final errorData = jsonDecode(response.body);
            errorMessage = errorData['message']?.toString() ?? 
                          errorData['error']?.toString() ?? 
                          'Error del servidor (${response.statusCode})';
          } else {
            errorMessage = 'Error del servidor (${response.statusCode}) - Sin mensaje';
          }
        } catch (e) {
          errorMessage = 'Error del servidor (${response.statusCode}) - Respuesta inv√°lida';
        }
        
        await _mostrarAlertaAsync(
          QuickAlertType.error,
          'Error al crear orden',
          errorMessage,
          'OK',
          Color(0xFFE74C3C),
        );
        return false;
      }

    } catch (e) {
      print('‚ùå Error cr√≠tico al crear orden: $e');
      
      String errorMessage = 'Error de conexi√≥n desconocido';
      if (e.toString().contains('TimeoutException')) {
        errorMessage = 'Tiempo de espera agotado. Verifica tu conexi√≥n a internet.';
      } else if (e.toString().contains('SocketException')) {
        errorMessage = 'No se puede conectar al servidor. Verifica la conexi√≥n.';
      } else if (e.toString().contains('FormatException')) {
        errorMessage = 'Error en el formato de datos del servidor.';
      } else {
        errorMessage = 'Error de conexi√≥n: ${e.toString()}';
      }
      
      await _mostrarAlertaAsync(
        QuickAlertType.error,
        'Error de Conexi√≥n',
        errorMessage,
        'OK',
        Color(0xFFE74C3C),
      );
      return false;
    } finally {
      isCreatingOrder.value = false;
    }
  }

  // ‚úÖ NUEVA FUNCI√ìN: Mostrar alertas de forma as√≠ncrona y segura
  Future<void> _mostrarAlertaAsync(
    QuickAlertType type,
    String title,
    String text,
    String confirmBtnText,
    Color confirmBtnColor,
  ) async {
    try {
      if (Get.context != null) {
        await QuickAlert.show(
          context: Get.context!,
          type: type,
          title: title,
          text: text,
          confirmBtnText: confirmBtnText,
          confirmBtnColor: confirmBtnColor,
          barrierDismissible: false,
        );
      } else {
        print('‚ö†Ô∏è No se puede mostrar alerta - contexto no disponible');
      }
    } catch (e) {
      print('‚ùå Error mostrando alerta: $e');
    }
  }

  /// Refrescar todos los datos
  Future<void> refrescarDatos() async {
    try {
      await cargarDatosIniciales();
    } catch (e) {
      print('‚ùå Error en refrescarDatos: $e');
      _mostrarError('Error', 'No se pudieron refrescar los datos');
    }
  }

  /// Mostrar error con QuickAlert
  void _mostrarError(String titulo, String mensaje) {
    try {
      if (Get.context != null) {
        QuickAlert.show(
          context: Get.context!,
          type: QuickAlertType.error,
          title: titulo,
          text: mensaje,
          confirmBtnText: 'OK',
          confirmBtnColor: Color(0xFFE74C3C),
        );
      } else {
        print('‚ö†Ô∏è No se puede mostrar error - contexto no disponible: $titulo - $mensaje');
      }
    } catch (e) {
      print('‚ùå Error mostrando mensaje de error: $e');
    }
  }

  /// Validar si se puede crear la orden
  bool get puedeCrearOrden {
    try {
      return selectedMesa.value != null && 
             cartItems.isNotEmpty && 
             !isCreatingOrder.value;
    } catch (e) {
      print('‚ùå Error en puedeCrearOrden: $e');
      return false;
    }
  }
}